<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <!-- not sure if this is good or bad for mobile
    <!--<meta name="viewport" content="width=device-width, initial-scale=1">-->
    <title>Fractions Sidequest · Pagwin's website</title>
    <link rel="stylesheet" type="text/css" href="/static/css/layout.css" />
    <link rel="stylesheet" type="text/css" href="/static/css/colors.css" />
    <link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
    <script type="module" src="/static/js/code_highlighting.mjs"></script>
</head>

<body class="light">
    <!-- originally handled dark v light via js but decided it would be better to just do it all in css and have no toggle 8a7917a0cd34bd7637d9a9a8ad327e4b847cdeed is the last commit where I had the system setup -->
    <div id="header">
        <a class="nav-link" href="/">Home</a>
        <a class="nav-link" href="/posts/">Blog Posts</a>
        <a class="nav-link" href="/links/">Links</a>
    </div>
    <div id="content-outer">
        <div id="content">
            <header>
    <h1 style="font-variant: small-caps;">Fractions Sidequest</h1>
    <div class="info">
        2023-08-08
    </div>
</header>
<hr>
</hr>
<article>
    <h1 id="the-sidequest">The Sidequest</h1>
<p>Welcome to a blog post about a sidequest I went on while exploring a
computer <a href="/blog/fractions">fraction</a> based number system.
Specifically for my third solution I wanted to generate a list of
fractions generated by the algorithm from <a
href="https://www.youtube.com/watch?v=4d6YrTKmjfE">the video</a>.</p>
<h2 id="algorithm-recap">Algorithm recap</h2>
<p>the algorithm is decently simple but knowing it is a bit of a
pre-requisite for the rest of this post. As such the steps are
below.</p>
<ol type="1">
<li>Start with a pair of fractions you want the generated fractions to
range over(there are probably restrictions on what you can pick but for
the rest of this post assume they’re 0/1 and 1/0 which are fine and
allow for ranging over the entire number line)</li>
<li>Add the numerators and denominators of the 2 fractions</li>
<li>Put the newly created fraction between the fractions used to
generate it</li>
<li>repeat with all fractions next to each other in the list for however
long you want for more fractions(you won’t get repeats)</li>
</ol>
<h2 id="script-1">Script 1</h2>
<p>I wanted to use a fast lang for this so I chose Rust(also because I
personally like Rust). It didn’t take long for me to write this(slightly
changed for clarity)</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rs"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main()<span class="op">-&gt;</span><span class="pp">anyhow::</span><span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">&gt;{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> fracs <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span><span class="op">&lt;</span>Frac<span class="op">&gt;</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    fracs<span class="op">.</span>push(Frac(<span class="dv">0</span><span class="op">,</span><span class="dv">1</span>))<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    fracs<span class="op">.</span>push(Frac(<span class="dv">1</span><span class="op">,</span><span class="dv">0</span>))<span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="dv">0</span><span class="op">..</span><span class="dv">19</span><span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="pp">eprintln!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span>i)<span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        step(<span class="op">&amp;</span><span class="kw">mut</span> fracs)<span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">//remaining code in main wrote the fractions to a file and didn&#39;t change, maybe I could&#39;ve written it to be faster but that&#39;s not the focus of this blog</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Ok</span>(())</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> step(list<span class="op">:&amp;</span><span class="kw">mut</span> <span class="dt">Vec</span><span class="op">&lt;</span>Frac<span class="op">&gt;</span>)<span class="op">{</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// I wanted a progress bar and in this case it actually is the reason I even knew there was a performance problem</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> bar <span class="op">=</span> <span class="pp">indicatif::ProgressBar::</span>new(list<span class="op">.</span>len() <span class="kw">as</span> <span class="dt">u64</span>)<span class="op">;</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&lt;</span> list<span class="op">.</span>len()<span class="op">-</span><span class="dv">1</span><span class="op">{</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        bar<span class="op">.</span>inc(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        list<span class="op">.</span>insert(i<span class="op">+</span><span class="dv">1</span><span class="op">,</span>list[i]<span class="op">+</span>list[i<span class="op">+</span><span class="dv">1</span>])<span class="op">;</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        i<span class="op">+=</span><span class="dv">2</span><span class="op">;</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    bar<span class="op">.</span>finish_and_clear()<span class="op">;</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="co">// trait impls are for convenience</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Clone</span><span class="op">,</span> <span class="bu">Copy</span><span class="at">)]</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Frac(<span class="dt">u16</span><span class="op">,</span><span class="dt">u16</span>)<span class="op">;</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="bu">Add</span> <span class="cf">for</span> Frac<span class="op">{</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Output <span class="op">=</span> <span class="dt">Self</span><span class="op">;</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> add(<span class="kw">self</span><span class="op">,</span> rhs<span class="op">:</span> <span class="dt">Self</span>) <span class="op">-&gt;</span> <span class="dt">Self</span><span class="pp">::</span>Output <span class="op">{</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>        Frac(<span class="kw">self</span><span class="op">.</span><span class="dv">0</span><span class="op">+</span>rhs<span class="op">.</span><span class="dv">0</span><span class="op">,</span><span class="kw">self</span><span class="op">.</span><span class="dv">1</span><span class="op">+</span>rhs<span class="op">.</span><span class="dv">1</span>)</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This code feels bad even from a code quality point of view but idk
why, regardless it’s hilariously bad performance wise.</p>
<video width="700" height="400" controls src="/video/frac_gen_v1.mp4">
</video>
<p>Considering that we’re “only” doing addition this is incredibly slow.
Slower than addition in (insert butt of the joke language of this week
here). All that in mind something is definitely up and if you read the
code above and think about it enough you’ll probably see it.</p>
<p>… Yeah the problem is this line here</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rs"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>list<span class="op">.</span>insert(i<span class="op">+</span><span class="dv">1</span><span class="op">,</span>list[i]<span class="op">+</span>list[i<span class="op">+</span><span class="dv">1</span>])<span class="op">;</span></span></code></pre></div>
<p>Citing documentation</p>
<blockquote>
<p>Inserts an element at position index within the vector,
<strong>shifting all elements after it to the right</strong>.</p>
</blockquote>
<p>In this case all elements after it is tens of millions of values to
put this in big O notation, doing things this way for every element
makes this process O(n²).</p>
<p>The solution is of course simple, don’t ever put anything into a vec
anywhere other than the end(barring witchcraft). Unfortunately
implementing that solution required rewriting this code. But I took this
as a nice oppurtunity to also multi-thread this code.</p>
<h2 id="concurrency-how">Concurrency how?</h2>
<p>Unfortunately this isn’t quite trivially parallizable so I can’t just
use rayon. In the face of this a very naive solution to this problem
would be something like</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rs"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">// ignoring move semantics and the need to only use functions that exist for convenience and readability</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> recurse(f1<span class="op">:</span>Frac<span class="op">,</span> f2<span class="op">:</span>Frac<span class="op">,</span> remaining<span class="op">:</span><span class="dt">usize</span>)<span class="op">-&gt;</span><span class="dt">Vec</span><span class="op">&lt;</span>Frac<span class="op">&gt;{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> middle <span class="op">=</span> f1<span class="op">+</span>f2<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> left_thread <span class="op">=</span> <span class="pp">std::thread::</span>spawn(<span class="op">||</span>recurse(f1<span class="op">,</span>middle<span class="op">,</span>remaining<span class="op">-</span><span class="dv">1</span>))<span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> right_thread <span class="op">=</span> <span class="pp">std::thread::</span>spawn(<span class="op">||</span>recurse(middle<span class="op">,</span>f2<span class="op">,</span>remaining<span class="op">-</span><span class="dv">1</span>))<span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> left <span class="op">=</span> left_thread<span class="op">.</span>join()<span class="op">;</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> right <span class="op">=</span> right_thread<span class="op">.</span>join()<span class="op">;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">//don&#39;t need return but not everyone knows rust</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> concat(left<span class="op">,</span> middle<span class="op">,</span> right)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>the reason I call this the naive solution is because it uses OS
threads and OS threads are expensive memory wise. Also if you spawn more
of them than CPU cores you get minimal benefit and if you keep spawning
them anyways the OS tends to have a panic attack. That’s bad so instead
of using OS threads lets use green threads for less overhead while still
using multiple threads from a pool.</p>
<h2 id="script-2">Script 2</h2>
<div class="sourceCode" id="cb4"><pre class="sourceCode rs"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span><span class="pp">tokio::</span>main<span class="at">]</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> main()<span class="op">-&gt;</span><span class="pp">anyhow::</span><span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">&gt;{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> RECURSIONS<span class="op">:</span><span class="dt">u64</span> <span class="op">=</span> <span class="dv">19</span><span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> fracs <span class="op">=</span> recurse(Frac(<span class="dv">0</span><span class="op">,</span><span class="dv">1</span>)<span class="op">,</span>Frac(<span class="dv">1</span><span class="op">,</span><span class="dv">0</span>)<span class="op">,</span>RECURSIONS)<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Ok</span>(())</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="co">// actual code is much more ugly in reality due to reasons(code below won&#39;t compile), if you wanna see it there&#39;s a link to the repo with all this code at the bottom of the article, the git commit is de72a7a0</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co">// also removing progress bar code because nobody cares just know I still had a progress bar</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> recurse(f1<span class="op">:</span>Frac<span class="op">,</span>f2<span class="op">:</span>Frac<span class="op">,</span> remaining<span class="op">:</span><span class="dt">u64</span>)<span class="op">-&gt;</span><span class="dt">Vec</span><span class="op">&lt;</span>Frac<span class="op">&gt;{</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// base case for the recusion</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> remaining <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dt">Vec</span><span class="pp">::</span>new()</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// same idea as the naive version</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> middle <span class="op">=</span> f1<span class="op">+</span>f2<span class="op">;</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> left_task <span class="op">=</span> <span class="pp">tokio::task::</span>spawn(recurse(f1<span class="op">,</span>middle<span class="op">,</span>remaining<span class="op">-</span><span class="dv">1</span>))<span class="op">;</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> right_task <span class="op">=</span> <span class="pp">tokio::task::</span>spawn(recurse(middle<span class="op">,</span>f2<span class="op">,</span>remaining<span class="op">-</span><span class="dv">1</span>))<span class="op">;</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> left <span class="op">=</span> left_task<span class="op">.</span><span class="kw">await</span><span class="op">.</span>expect(<span class="st">&quot;left future failure&quot;</span>)<span class="op">;</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> right <span class="op">=</span> right_task<span class="op">.</span><span class="kw">await</span><span class="op">.</span>expect(<span class="st">&quot;right future failure&quot;</span>)<span class="op">;</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// how concat is being achieved</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> ret <span class="op">=</span> left<span class="op">;</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>    ret<span class="op">.</span>push(middle)<span class="op">;</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>    ret<span class="op">.</span>append(<span class="op">&amp;</span><span class="kw">mut</span> right)<span class="op">;</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ret</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a><span class="co">// Frac is the same as before</span></span></code></pre></div>
<p>looks good at first glance(actual version code quality is bad but
blog version seems alright). What happens when we run it?</p>
<video width="700" height="400" controls src="/video/frac_gen_v2.mp4">
</video>
<p>Oh… we run out of memory… or well we run out of 30 gigabytes of
memory because I set a limit to avoid effecting the other stuff running
on the server(because it isn’t mine). But why? Doing the math if all we
had to deal with was the fractions we’d be using about
<code>17501876*4/1000**3 ~ 0.07 GB</code>, if we include the overhead of
all the Vecs we make and are pretty agressive with how much memory they
use maybe 0.21 GB which is a difference of over 142x. So what’s the rest
of the memory?</p>
<p>Well… I’m not 100% sure actually but my current best guess is the
green threads/tokio tasks. Whatever it is on average it seems to have
memory usage measured in hundreds of bytes and/or a kilobyte or 2
roughly doing a bit of quick math(I just divided
30GB/num_of_running_tasks). So I guess I gotta take out the green thread
usage huh.</p>
<h2 id="script-3the-finale-for-now">Script 3(the finale for now)</h2>
<p>So yeah I did that, I didn’t need to rewrite this time just a
refactor.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode rs"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main()<span class="op">-&gt;</span><span class="pp">anyhow::</span><span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">&gt;{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> RECURSIONS<span class="op">:</span><span class="dt">u64</span> <span class="op">=</span> <span class="dv">32</span><span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> fracs <span class="op">=</span> recurse(Frac(<span class="dv">0</span><span class="op">,</span><span class="dv">1</span>)<span class="op">,</span>Frac(<span class="dv">1</span><span class="op">,</span><span class="dv">0</span>)<span class="op">,</span>RECURSIONS)<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Ok</span>(())</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> recurse(f1<span class="op">:</span>Frac<span class="op">,</span>f2<span class="op">:</span>Frac<span class="op">,</span> remaining<span class="op">:</span><span class="dt">u64</span>)<span class="op">-&gt;</span><span class="dt">Vec</span><span class="op">&lt;</span>Frac<span class="op">&gt;{</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// nothing new here</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> remaining <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dt">Vec</span><span class="pp">::</span>new()</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> middle <span class="op">=</span> f1<span class="op">+</span>f2<span class="op">;</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> left <span class="op">=</span> recurse(f1<span class="op">,</span>middle<span class="op">,</span>remaining<span class="op">-</span><span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> right <span class="op">=</span> recurse(middle<span class="op">,</span>f2<span class="op">,</span>remaining<span class="op">-</span><span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> ret <span class="op">=</span> left<span class="op">;</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    ret<span class="op">.</span>reserve(ret<span class="op">.</span>len()<span class="op">+</span>right<span class="op">.</span>len()<span class="op">+</span><span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    ret<span class="op">.</span>push(middle)<span class="op">;</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    ret<span class="op">.</span>append(<span class="op">&amp;</span><span class="kw">mut</span> right)<span class="op">;</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ret</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a><span class="co">// Frac now uses 32 bit ints rather than 16 bit ints due to an overflow</span></span></code></pre></div>
<p>This solves the whole running out of memory thing. A funny side
effect is that now it’s even faster(even though it’s 1 thread).</p>
<video width="700" height="400" controls src="/video/frac_gen_v3.mp4">
</video>
<p>So that was fun going through and making all this work out well, now
I can generate gigabytes upon gigabytes of fractions with ease.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Could I optimize this more? Yes I could pre-allocate a buffer and use
a specialized thread pool(and probably some unsafe code as well thinking
about it). But I won’t because it’s fast enough, the remaining speed
gains probably aren’t worth it and most of the execution time is spent
writing the results to disk. Overall this was a fun sidequest as a part
of the fraction quest. I did other stuff between the article before the
fraction one and the fraction one and maybe I’ll dump those articles at
some point soon so I can stop feeling bad about them sitting in my
website’s git repo doing nothing.</p>
<p><a href="https://github.com/Pagwin-Fedora/fraction_generator">git
repo with the generator</a></p>
</article>

        </div>
    </div>
    <div id="footer">
    </div>
</body>

</html>
